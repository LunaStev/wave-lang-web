"use strict";(globalThis.webpackChunkwave_lang=globalThis.webpackChunkwave_lang||[]).push([[621],{7044(e,a,s){s.r(a),s.d(a,{assets:()=>c,contentTitle:()=>i,default:()=>l,frontMatter:()=>t,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"syntax/struct","title":"Estructura","description":"Resumen","source":"@site/i18n/es/docusaurus-plugin-content-docs/current/syntax/struct.md","sourceDirName":"syntax","slug":"/syntax/struct","permalink":"/es/docs/syntax/struct","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"sidebar_position":8},"sidebar":"tutorialSidebar","previous":{"title":"Ensambliado en l\xednea","permalink":"/es/docs/syntax/inline_asm"},"next":{"title":"FFI","permalink":"/es/docs/syntax/ffi"}}');var r=s(4848),o=s(8453);const t={sidebar_position:8},i="Estructura",c={},d=[{value:"Resumen",id:"resumen",level:2},{value:"Las estructuras en Wave funcionan como tipos por valor (value types).\nTodos los campos deben tener un tipo expl\xedcito y cuando se crea una instancia de estructura, todos los campos deben estar inicializados.\nEstas reglas aseguran que el estado de la estructura sea siempre completo y predecible.",id:"las-estructuras-en-wave-funcionan-como-tipos-por-valor-value-typestodos-los-campos-deben-tener-un-tipo-expl\xedcito-y-cuando-se-crea-una-instancia-de-estructura-todos-los-campos-deben-estar-inicializadosestas-reglas-aseguran-que-el-estado-de-la-estructura-sea-siempre-completo-y-predecible",level:2},{value:"Sintaxis de declaraci\xf3n de estructura",id:"sintaxis-de-declaraci\xf3n-de-estructura",level:2},{value:"El orden en que se escriben los campos al declarar una estructura es el mismo que se utiliza para el orden de disposici\xf3n en memoria.\nDentro de una estructura solo se permiten declaraciones de campos y no se pueden incluir funciones o m\xe9todos.\nLa l\xf3gica operativa se define por separado fuera de la estructura.",id:"el-orden-en-que-se-escriben-los-campos-al-declarar-una-estructura-es-el-mismo-que-se-utiliza-para-el-orden-de-disposici\xf3n-en-memoriadentro-de-una-estructura-solo-se-permiten-declaraciones-de-campos-y-no-se-pueden-incluir-funciones-o-m\xe9todosla-l\xf3gica-operativa-se-define-por-separado-fuera-de-la-estructura",level:2},{value:"Sintaxis de creaci\xf3n de estructura",id:"sintaxis-de-creaci\xf3n-de-estructura",level:2},{value:"Sintaxis de acceso a campo de estructura",id:"sintaxis-de-acceso-a-campo-de-estructura",level:2},{value:"Sintaxis de definici\xf3n de m\xe9todo de estructura",id:"sintaxis-de-definici\xf3n-de-m\xe9todo-de-estructura",level:2},{value:"Uso de estructuras como argumentos de funciones",id:"uso-de-estructuras-como-argumentos-de-funciones",level:2},{value:"Estructura anidada (Nested Struct)",id:"estructura-anidada-nested-struct",level:2},{value:"Arreglo de estructuras",id:"arreglo-de-estructuras",level:2},{value:"Compatibilidad de operaciones b\xe1sicas de estructuras",id:"compatibilidad-de-operaciones-b\xe1sicas-de-estructuras",level:2}];function u(e){const a={code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(a.header,{children:(0,r.jsx)(a.h1,{id:"estructura",children:"Estructura"})}),"\n",(0,r.jsx)(a.h2,{id:"resumen",children:"Resumen"}),"\n",(0,r.jsx)(a.p,{children:"Las estructuras en el lenguaje Wave son un elemento sint\xe1ctico clave para declarar tipos de datos definidos por el usuario.\nEl uso de estructuras permite agrupar y representar valores de diferentes tipos como una sola unidad l\xf3gica, lo que permite modelar estructuras de datos complejas de manera clara y segura."}),"\n",(0,r.jsx)(a.h2,{id:"las-estructuras-en-wave-funcionan-como-tipos-por-valor-value-typestodos-los-campos-deben-tener-un-tipo-expl\xedcito-y-cuando-se-crea-una-instancia-de-estructura-todos-los-campos-deben-estar-inicializadosestas-reglas-aseguran-que-el-estado-de-la-estructura-sea-siempre-completo-y-predecible",children:"Las estructuras en Wave funcionan como tipos por valor (value types).\nTodos los campos deben tener un tipo expl\xedcito y cuando se crea una instancia de estructura, todos los campos deben estar inicializados.\nEstas reglas aseguran que el estado de la estructura sea siempre completo y predecible."}),"\n",(0,r.jsx)(a.h2,{id:"sintaxis-de-declaraci\xf3n-de-estructura",children:"Sintaxis de declaraci\xf3n de estructura"}),"\n",(0,r.jsxs)(a.p,{children:["Una estructura se declara utilizando la palabra clave ",(0,r.jsx)(a.code,{children:"struct"}),".\nEl nombre de la estructura utiliza la notaci\xf3n PascalCase, y el cuerpo de la estructura puede definir uno o m\xe1s campos."]}),"\n",(0,r.jsxs)(a.p,{children:["Los campos se declaran en el formato ",(0,r.jsx)(a.code,{children:"nombre: tipo;"})," y cada declaraci\xf3n de campo debe terminar con un punto y coma."]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-wave",children:"struct Caja {\n tama\xf1o: i32;\n peso: f32;\n}\n"})}),"\n",(0,r.jsx)(a.h2,{id:"el-orden-en-que-se-escriben-los-campos-al-declarar-una-estructura-es-el-mismo-que-se-utiliza-para-el-orden-de-disposici\xf3n-en-memoriadentro-de-una-estructura-solo-se-permiten-declaraciones-de-campos-y-no-se-pueden-incluir-funciones-o-m\xe9todosla-l\xf3gica-operativa-se-define-por-separado-fuera-de-la-estructura",children:"El orden en que se escriben los campos al declarar una estructura es el mismo que se utiliza para el orden de disposici\xf3n en memoria.\nDentro de una estructura solo se permiten declaraciones de campos y no se pueden incluir funciones o m\xe9todos.\nLa l\xf3gica operativa se define por separado fuera de la estructura."}),"\n",(0,r.jsx)(a.h2,{id:"sintaxis-de-creaci\xf3n-de-estructura",children:"Sintaxis de creaci\xf3n de estructura"}),"\n",(0,r.jsxs)(a.p,{children:["Una estructura se crea en un formato literal utilizando el nombre de la estructura.\nUn literal de estructura es ",(0,r.jsx)(a.code,{children:"NombreDeEstructura { nombreDelCampo: valor; ... }"}),"."]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-wave",children:"var b: Caja = Caja {\n tama\xf1o: 42;\n peso: 10.5;\n};\n"})}),"\n",(0,r.jsx)(a.p,{children:"Al crear una estructura, todos los campos definidos deben inicializarse necesariamente, y si falta alguno, se producir\xe1 un error de compilaci\xf3n."}),"\n",(0,r.jsx)(a.p,{children:"Al inicializar, el orden de los campos no necesita coincidir con el orden de declaraci\xf3n de la estructura, pero el tipo de los valores pasados a cada campo debe coincidir exactamente con el tipo definido en la estructura.\nWave no permite la conversi\xf3n impl\xedcita de tipos durante el proceso de inicializaci\xf3n de campos de estructuras."}),"\n",(0,r.jsx)(a.hr,{}),"\n",(0,r.jsx)(a.h2,{id:"sintaxis-de-acceso-a-campo-de-estructura",children:"Sintaxis de acceso a campo de estructura"}),"\n",(0,r.jsx)(a.p,{children:"Los campos de una estructura se acceden mediante la notaci\xf3n de punto.\nEl acceso a los campos utiliza la misma sintaxis tanto para lectura como para escritura."}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-wave",children:'println("Tama\xf1o: {}", b.tama\xf1o);\nprintln("Peso: {}", b.peso);\n'})}),"\n",(0,r.jsx)(a.p,{children:"Intentar utilizar un nombre de campo inexistente provocar\xe1 un error en la etapa de compilaci\xf3n.\nLa estructura es un tipo de valor, por lo que al asignar la estructura completa o pasarla como argumento de funci\xf3n, todos los campos incluidos en la estructura se copian juntos."}),"\n",(0,r.jsx)(a.hr,{}),"\n",(0,r.jsx)(a.h2,{id:"sintaxis-de-definici\xf3n-de-m\xe9todo-de-estructura",children:"Sintaxis de definici\xf3n de m\xe9todo de estructura"}),"\n",(0,r.jsxs)(a.p,{children:["El lenguaje Wave no permite definir m\xe9todos directamente dentro de una estructura.\nEn su lugar, se utiliza la palabra clave ",(0,r.jsx)(a.code,{children:"proto"})," para declarar un conjunto de m\xe9todos asociados a la estructura."]}),"\n",(0,r.jsxs)(a.p,{children:["El bloque ",(0,r.jsx)(a.code,{children:"proto"})," es el \xe1mbito de las funciones pertenecientes a una estructura espec\xedfica, y las funciones definidas en este bloque se usan como m\xe9todos de dicha estructura."]}),"\n",(0,r.jsxs)(a.p,{children:["El m\xe9todo utiliza ",(0,r.jsx)(a.code,{children:"self"})," como el primer par\xe1metro para recibir una instancia de estructura.\n",(0,r.jsx)(a.code,{children:"self"})," representa el valor completo de la estructura y se pasa por copia de valor."]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-wave",children:'prototipo Caja {\n    fun print(self) {\n        println("tama\xf1o={}, peso={}", self.size, self.weight);\n    }\n\n    fun tama\xf1o_agregado(self, x: i32) -> i32 {\n        return self.size + x;\n    }\n}\n'})}),"\n",(0,r.jsxs)(a.p,{children:["El bloque ",(0,r.jsx)(a.code,{children:"proto"})," no necesita estar en el mismo archivo que la declaraci\xf3n de la estructura y se pueden definir m\xe9todos para la misma estructura en varios bloques ",(0,r.jsx)(a.code,{children:"proto"}),"."]}),"\n",(0,r.jsx)(a.p,{children:"La llamada al m\xe9todo utiliza la notaci\xf3n de punto y funciona de la misma manera que las llamadas de funci\xf3n normales."}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-wave",children:"b.print();\nvar n: i32 = b.tama\xf1o_agregado(5);\n"})}),"\n",(0,r.jsx)(a.hr,{}),"\n",(0,r.jsx)(a.h2,{id:"uso-de-estructuras-como-argumentos-de-funciones",children:"Uso de estructuras como argumentos de funciones"}),"\n",(0,r.jsx)(a.p,{children:"Las estructuras se procesan por copia de valor cuando se transmiten como argumentos de funci\xf3n.\nIncluso si se modifican los campos de la estructura dentro de una funci\xf3n, no afecta a la instancia de la estructura que hizo la llamada."}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-wave",children:"fun calc(caja: Caja) -> i32 {\n    return caja.size * 2;\n}\n"})}),"\n",(0,r.jsx)(a.p,{children:"Incluso cuando se utiliza una estructura como valor de retorno de una funci\xf3n, ocurre una copia de valor.\nEste comportamiento garantiza la inmutabilidad de la estructura y un flujo de datos predecible."}),"\n",(0,r.jsx)(a.hr,{}),"\n",(0,r.jsx)(a.h2,{id:"estructura-anidada-nested-struct",children:"Estructura anidada (Nested Struct)"}),"\n",(0,r.jsx)(a.p,{children:"En Wave, se puede utilizar otra estructura como tipo de campo de una estructura.\nLas estructuras son tipos completos, por lo que se pueden anidar libremente incluyendo una estructura dentro de otra."}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-wave",children:"struct Posici\xf3n {\n    x: i32;\n    y: i32;\n}\n\nstruct Jugador {\n    nombre: str;\n    pos: Posici\xf3n;\n}\n"})}),"\n",(0,r.jsx)(a.p,{children:"Los campos de estructuras anidadas se acceden mediante el uso continuo de notaci\xf3n de punto."}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-wave",children:'var p: Jugador = Jugador {\n    nombre: "Alice";\n    pos: Posici\xf3n { x: 10; y: 20; };\n};\n\nprintln("Jugador X: {}", p.pos.x);\nprintln("Jugador Y: {}", p.pos.y);\n'})}),"\n",(0,r.jsx)(a.p,{children:"Se puede anidar un literal de estructura dentro de otro literal de estructura y las reglas de inicializaci\xf3n de campos se aplican de la misma manera."}),"\n",(0,r.jsx)(a.hr,{}),"\n",(0,r.jsx)(a.h2,{id:"arreglo-de-estructuras",children:"Arreglo de estructuras"}),"\n",(0,r.jsxs)(a.p,{children:["Las estructuras se pueden utilizar como tipo de elemento en un arreglo.\nLa sintaxis de arreglos en Wave utiliza el formato ",(0,r.jsx)(a.code,{children:"array<tipo, tama\xf1o>"})," y se pueden especificar tipos de estructuras de manera similar."]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-wave",children:'var jugadores: array<Jugador, 3> = [\n    Jugador { nombre: "A"; pos: Posici\xf3n { x: 1; y: 2; }; },\n    Jugador { nombre: "B"; pos: Posici\xf3n { x: 3; y: 4; }; },\n    Jugador { nombre: "C"; pos: Posici\xf3n { x: 5; y: 6; }; }\n];\n'})}),"\n",(0,r.jsx)(a.p,{children:"Al acceder a elementos de un arreglo de estructuras, se utiliza primero el \xedndice del arreglo seguido de la notaci\xf3n de punto para acceder a los campos dentro de la estructura."}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-wave",children:'println("Segundo Jugador X: {}", jugadores[1].pos.x);\n'})}),"\n",(0,r.jsx)(a.hr,{}),"\n",(0,r.jsx)(a.h2,{id:"compatibilidad-de-operaciones-b\xe1sicas-de-estructuras",children:"Compatibilidad de operaciones b\xe1sicas de estructuras"}),"\n",(0,r.jsx)(a.p,{children:"Las estructuras en Wave son tipos definidos por el usuario, por lo tanto, no participan autom\xe1ticamente en operaciones aritm\xe9ticas o de comparaci\xf3n."}),"\n",(0,r.jsxs)(a.p,{children:["Si se necesita comparaci\xf3n de igualdad, ordenamiento, hashing o c\xe1lculos num\xe9ricos para estructuras, esos comportamientos deben definirse expl\xedcitamente a trav\xe9s de un bloque ",(0,r.jsx)(a.code,{children:"proto"}),".\nWave no proporciona operadores impl\xedcitos para estructuras; se requiere que todas las operaciones se definan expl\xedcitamente."]})]})}function l(e={}){const{wrapper:a}={...(0,o.R)(),...e.components};return a?(0,r.jsx)(a,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},8453(e,a,s){s.d(a,{R:()=>t,x:()=>i});var n=s(6540);const r={},o=n.createContext(r);function t(e){const a=n.useContext(o);return n.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function i(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),n.createElement(o.Provider,{value:a},e.children)}}}]);