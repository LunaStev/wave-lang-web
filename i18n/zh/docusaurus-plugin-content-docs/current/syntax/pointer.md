---
sidebar_position: 6
---

# 指针

## 介绍

该文档介绍了 Wave 语言提供的指针功能及其使用方法。
Wave 作为支持低级系统编程的语言，提供指针功能以应对需要显式内存地址操作的情况。

Wave의 포인터 설계는 **Wave Explicit Memory Type Model**을 기반으로 합니다.
이 모델은 포인터와 배열을 문법적 트릭이나 라이브러리 추상화가 아닌,
언어 차원의 **명시적인 메모리 타입**으로 정의하는 것을 목표로 합니다.

이러한 설계에 따라 Wave에서는 포인터를 `ptr<T>` 형태의 타입으로 표현하며,
이는 특정 타입 `T`의 값을 저장하고 있는 메모리 주소를 가리키는 타입임을 명확하게 드러냅니다.
이 접근 방식은 포인터를 연산자나 선언 문법이 아닌,
타입 시스템의 일부로 다룸으로써 메모리 구조를 더 직관적이고 일관되게 표현할 수 있게 합니다.

포인터는 특정 타입의 메모리 주소를 가리키는 변수이며,
이를 통해 메모리에 저장된 값에 직접 접근하거나 해당 값을 수정할 수 있습니다.
이 기능은 시스템 소프트웨어, 네이티브 라이브러리, 성능이 중요한 코드,
하드웨어 제어와 같은 영역에서 핵심적인 역할을 합니다.

---

## 指针声明

在 Wave 中，指针以 `ptr<类型>` 形式声明。
这清楚地表明这是一个指向存有该类型值的内存地址的指针。

例如，指向 `i32` 类型值的指针可以这样声明。

```wave
var p: ptr<i32>;
```

这个声明创建一个尚未指向任何内存的指针变量，之后可以初始化为一个实际地址。

---

## 指针初始化

指针可以通过引用变量的地址进行初始化。
在 Wave 中，使用地址运算符 `&` 来获取变量的内存地址。

```wave
var a: i32 = 10;
var p: ptr<i32> = &a;
```

在上述代码中，`&a` 表示变量 `a` 存储的内存地址，指针 `p` 指向该地址。
从这一刻起，可以通过 `p` 直接访问 `a` 的值。

---

## 指针解引用

需要解引用以读取或修改指针指向的实际值。
在 Wave 中，使用 `deref` 关键字对指针进行解引用。

```wave
var a: i32 = 10;
var p: ptr<i32> = &a;

println("{}", deref p); // 输出10

deref p = 20;
println("{}", a); // 输出20
```

在此示例中，`deref p` 是指针 `p` 指向的内存位置的值。
可以读取值，也可以赋予新值以更改原变量的内容。

---

## NULL指针

在 Wave 中，指向无效内存的指针用 `null` 关键字表示。
指针变量可以显式初始化为 `null`，此时不引用任何内存地址。

```wave
var p: ptr<i32> = null;
```

空指针用于表示故意未初始化的状态。
在 Wave 中，尝试在编译阶段检测并处理空指针解引用为错误，以防止运行时错误或未定义行为。

---

## 多重指针

Wave 支持多级指针，通过多个级别的指针提供的嵌套使用。
由于指针本身也是一个值，因此可以声明一个指向指针的指针。

```wave
var x: i32 = 1;
var p1: ptr<i32> = &x;
var p2: ptr<ptr<i32>> = &p1;
var p3: ptr<ptr<ptr<i32>>> = &p2;

println("{}", deref p1); // 1
println("{}", deref deref p2); // 1
println("{}", deref deref deref p3); // 1
```

通过使用多级指针，可以表示间接引用结构，用于需要复杂内存结构或低级数据表示的情况。

---

## 数组和指针

指针不仅可以指向单个变量，也可以用于指向数组元素或整个数组。

如果数组的每个元素都是指针，可以通过指针数组间接引用多个内存位置。

```wave
var a: i32 = 10;
var b: i32 = 20;
var arr: array<ptr<i32>, 2> = [&a, &b];

println(
 "deref arr[0] = {}, deref arr[1] = {}",
 deref arr[0],
 deref arr[1]
); // 10, 20
```

也可以将整个数组指向一个指针。

```wave
var arr: ptr<array<i32, 3>> = &[1, 2, 3];
println("{}", arr); // 输出内存地址
```

这种方式在将数组传递给函数或进行低级内存处理时非常有用。

---

## 安全性和所有权

为了降低使用指针时可能出现的风险，Wave 的设计目标是引入类似于 Rust 的所有权和生命周期系统。

通过这种方式，力求在编译阶段尽可能防止无效指针解引用、悬空指针、双重释放等问题。
指针是强大的工具，但在 Wave 中应用限制和检查，使其以尽可能清晰和安全的方式使用。

```wave
fun main() {
 let x: i32 = 42;
 let p: ptr<i32> = &x;

 println("x = {}", deref p);

 deref p = 99;
 println("x = {}", x);
}
```

输出结果如下。

```text
x = 42
x = 99
```

此示例演示了可以通过指针安全地读取和修改变量的值。

---

## 结论

指针是 Wave 中实现高性能低级编程的核心功能之一。
在需要直接内存控制的系统开发、本地库实现、硬件控制等领域起着特别重要的作用。

Wave 保持了指针的强大功能，同时通过编译器级别的检查和语言设计，力求指针使用尽可能安全和可预测。
这样，开发者可以在性能和稳定性之间做出平衡的选择。