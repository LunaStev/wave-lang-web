---
sidebar_position: 6
---

# ポインター

## 紹介

この文書は、Wave 言語で提供されるポインタ機能とその利用方法について説明します。
Waveは低レベルなシステムプログラミングをサポートする言語で、明示的なメモリアドレス操作が必要な状況を考慮してポインタ機能を提供します。

Waveのポインタ設計は **Wave Explicit Memory Type Model** を基にしています。
このモデルは、ポインタと配列を文法的トリックやライブラリ抽象化ではなく、
言語レベルの **明示的なメモリタイプ** として定義することを目標としています。

このような設計により、Waveではポインタを `ptr<T>` 形式のタイプで表現し、
これは特定のタイプ `T` の値を保存しているメモリアドレスを指すタイプであることを明確に示します。
このアプローチはポインタを演算子や宣言文法としてではなく、
タイプシステムの一部として扱うことで、メモリ構造をより直感的で一貫して表現できます。

ポインタは特定のタイプのメモリアドレスを指す変数であり、
これによりメモリに保存された値に直接アクセスしたり、その値を修正したりすることができます。
この機能は、システムソフトウェア、ネイティブライブラリ、パフォーマンスが重要なコード、
ハードウェア制御などの分野で重要な役割を果たします。

---

## ポインター宣言

Waveでポインタは `ptr<型>` 形式で宣言します。
これは該当する型の値を保存しているメモリアドレスを指すポインタであることを明確に表現します。

例えば、`i32` 型の値を指すポインタは次のように宣言できます。

```wave
var p: ptr<i32>;
```

この宣言はまだどのメモリも指していないポインタ変数を生成し、その後に実際のアドレスで初期化できます。

---

## ポインタ初期化

ポインタは変数のアドレスを参照することで初期化できます。
Waveではアドレス演算子 `&` を使用して変数のメモリアドレスを取得します。

```wave
var a: i32 = 10;
var p: ptr<i32> = &a;
```

上記コードでは `&a` は変数 `a` が保存されたメモリアドレスを意味し、
ポインタ `p` はそのアドレスを指すことになります。
この時点から `p` を通じて `a` の値に直接アクセスできます。

---

## ポインタ逆参照

ポインタが指す実際の値を読み取ったり修正したりするには逆参照が必要です。
Waveでは `deref` キーワードを使用してポインタを逆参照します。

```wave
var a: i32 = 10;
var p: ptr<i32> = &a;

println("{}", deref p); // 10 出力

deref p = 20;
println("{}", a); // 20 出力
```

この例で `deref p` はポインタ `p` が指すメモリ位置の値を意味します。
値を読み取ることもでき、新しい値を代入して元の変数の内容を変更することもできます。

---

## NULLポインタ

Waveでは有効なメモリを指さないポインタを `null` キーワードで表現します。
ポインタ変数は明示的に `null` で初期化でき、その場合どのメモリアドレスも参照しません。

```wave
var p: ptr<i32> = null;
```

ヌルポインタは意図的にまだ初期化されていない状態を表現する際に使用します。
Waveではヌルポインタを逆参照しようとする試みをコンパイル段階で検出し、エラーとして処理することで、
ランタイムエラーや定義されていない動作を防ぎます。

---

## 多重ポインタ

Waveはポインタを複数段階にネストして使用する多重ポインタをサポートします。
ポインタ自体も一つの値であるため、ポインタを指すポインタを宣言することが可能です。

```wave
var x: i32 = 1;
var p1: ptr<i32> = &x;
var p2: ptr<ptr<i32>> = &p1;
var p3: ptr<ptr<ptr<i32>>> = &p2;

println("{}", deref p1);               // 1
println("{}", deref deref p2);         // 1
println("{}", deref deref deref p3);   // 1
```

このように多重ポインタを使用すると、間接参照構造を表現でき、
複雑なメモリ構造や低水準データ表現が必要な場合に利用できます。

---

## 配列とポインタ

ポインタは単一の変数に限らず、配列要素や配列全体を指すのにも使用できます。

配列の各要素がポインタである場合、ポインタ配列を通じて複数のメモリ位置を間接的に参照することができます。

```wave
var a: i32 = 10;
var b: i32 = 20;
var arr: array<ptr<i32>, 2> = [&a, &b];

println(
    "deref arr[0] = {}, deref arr[1] = {}",
    deref arr[0],
    deref arr[1]
); // 10, 20
```

また、配列全体を一つのポインタで指すことも可能です。

```wave
var arr: ptr<array<i32, 3>> = &[1, 2, 3];
println("{}", arr); // メモリアドレス出力
```

この方式は配列を関数に渡したり、低水準メモリ処理時に有用に使用されます。

---

## 安全性と所有権

Waveはポインタ使用時に発生しうる危険を減らすため、
Rustに類似した概念の所有権とライフタイムシステムを導入することを目標に設計されています。

これにより無効なポインタ逆参照、ダングリングポインタ、二重解放などの問題をコンパイル段階で最大限防ごうとしています。
ポインタは強力なツールですが、Waveでは可能な限り明確で安全な方法で使用されるよう制限と検査を適用します。

```wave
fun main() {
    let x: i32 = 42;
    let p: ptr<i32> = &x;

    println("x = {}", deref p);

    deref p = 99;
    println("x = {}", x);
}
```

出力結果は次の通りです。

```text
x = 42
x = 99
```

この例ではポインタを通じて変数の値を安全に読み取り修正できることを示します。

---

## 結論

ポインタはWaveで高性能低レベルプログラミングを可能にする重要な機能の一つです。
直接的なメモリ制御が必要なシステム開発、ネイティブライブラリ実装、ハードウェア制御などの領域で特に重要な役割を果たします。

Waveはポインタの強力さを維持しつつも、コンパイラーレベルの検査と言語設計を通じて
可能な限り安全で予測可能なポインタ使用を志向します。
これにより開発者は性能と安定性の間でバランスの取れた選択をすることができます。