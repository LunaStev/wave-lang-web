---
sidebar_position: 6
---

# ポインター

## 紹介

このドキュメントはWave言語で提供されるポインタ機能とその活用方法について説明します。
Waveは低レベルシステムプログラミングをサポートする言語として、明示的なメモリアドレス操作が必要な状況を考慮してポインタ機能を提供します。

Wave의 포인터 설계는 **Wave Explicit Memory Type Model**을 기반으로 합니다.
이 모델은 포인터와 배열을 문법적 트릭이나 라이브러리 추상화가 아닌,
언어 차원의 **명시적인 메모리 타입**으로 정의하는 것을 목표로 합니다.

이러한 설계에 따라 Wave에서는 포인터를 `ptr<T>` 형태의 타입으로 표현하며,
이는 특정 타입 `T`의 값을 저장하고 있는 메모리 주소를 가리키는 타입임을 명확하게 드러냅니다.
이 접근 방식은 포인터를 연산자나 선언 문법이 아닌,
타입 시스템의 일부로 다룸으로써 메모리 구조를 더 직관적이고 일관되게 표현할 수 있게 합니다.

포인터는 특정 타입의 메모리 주소를 가리키는 변수이며,
이를 통해 메모리에 저장된 값에 직접 접근하거나 해당 값을 수정할 수 있습니다.
이 기능은 시스템 소프트웨어, 네이티브 라이브러리, 성능이 중요한 코드,
하드웨어 제어와 같은 영역에서 핵심적인 역할을 합니다.

---

## ポインター宣言

Waveでポインタは `ptr<タイプ>` 形式で宣言します。
これは、そのタイプの値を保存しているメモリアドレスを指すポインタであることを明確に表現します。

例えば、`i32` タイプの値を指すポインタは次のように宣言できます。

```wave
var p: ptr<i32>;
```

この宣言はまだどのメモリも指していないポインタ変数を生成し、その後で実際のアドレスに初期化することができます。

---

## ポインタ初期化

ポインタは変数のアドレスを参照することで初期化できます。
Waveではアドレス演算子`&`を使用して変数のメモリアドレスを取得します。

```wave
var a: i32 = 10;
var p: ptr<i32> = &a;
```

このコードでは`&a`は変数`a`が格納されたメモリアドレスを意味し、ポインタ`p`はそのアドレスを指します。
`p`を通じて`a`の値に直接アクセスすることができます。

---

## ポインタ逆参照

ポインタが指す実際の値を読み書きするには逆参照が必要です。
Waveでは`deref`キーワードを使用してポインタを逆参照します。

```wave
var a: i32 = 10;
var p: ptr<i32> = &a;

println("{}", deref p); // 10 出力

deref p = 20;
println("{}", a); // 20 出力
```

この例では、`deref p`はポインタ`p`が指すメモリ位置の値を意味します。
値を読み取ったり、新しい値を割り当てて元の変数の内容を変更することもできます。

---

## NULLポインタ

Waveでは有効なメモリを指さないポインタを`null`キーワードで表現します。
ポインタ変数は明示的に`null`で初期化することができ、この場合、どのメモリアドレスも参照しません。

```wave
var p: ptr<i32> = null;
```

ヌルポインタは意図的にまだ初期化されていない状態を表現するために使用されます。
Waveでは、ヌルポインタを逆参照しようとする試みをコンパイル段階で検出し、エラーとして処理することで、ランタイムエラーや未定義の動作を防ぎます。

---

## 多重ポインタ

Waveはポインタを複数段階でネストして使用する多重ポインタをサポートします。
ポインタ自体も一つの値ですので、ポインタを指すポインタを宣言することが可能です。

```wave
var x: i32 = 1;
var p1: ptr<i32> = &x;
var p2: ptr<ptr<i32>> = &p1;
var p3: ptr<ptr<ptr<i32>>> = &p2;

println("{}", deref p1);               // 1
println("{}", deref deref p2);         // 1
println("{}", deref deref deref p3);   // 1
```

このように多重ポインタを使用すると、間接参照構造を表現でき、複雑なメモリ構造や低レベルのデータ表現が必要な場合に利用できます。

---

## 配列とポインタ

ポインタは単一変数だけでなく、配列要素や配列全体を指すのにも使用できます。

配列の各要素がポインタである場合、ポインタ配列を通じて複数のメモリ位置を間接的に参照することができます。

```wave
var a: i32 = 10;
var b: i32 = 20;
var arr: array<ptr<i32>, 2> = [&a, &b];

println(
    "deref arr[0] = {}, deref arr[1] = {}",
    deref arr[0],
    deref arr[1]
); // 10, 20
```

また、配列全体を1つのポインタで指すことも可能です。

```wave
var arr: ptr<array<i32, 3>> = &[1, 2, 3];
println("{}", arr); // メモリアドレス出力
```

この方式は配列を関数へ渡す時や低レベルのメモリ処理に役立ちます。

---

## 安全性と所有権

Waveはポインタ使用時に発生する可能性のあるリスクを減らすため、Rustと類似の概念である所有権と寿命システムを導入することを目指して設計されています。

これにより無効なポインタ参照、ダングリングポインタ、二重解放といった問題をコンパイル段階で可能な限り防ぐことを目指します。
ポインタは強力なツールではありますが、Waveではできる限り明確かつ安全な方法で使用できるように制限と検査を適用しています。

```wave
fun main() {
    let x: i32 = 42;
    let p: ptr<i32> = &x;

    println("x = {}", deref p);

    deref p = 99;
    println("x = {}", x);
}
```

出力結果は次の通りです。

```text
x = 42
x = 99
```

この例では、ポインタを通じて変数の値を安全に読み書きできることを示しています。

---

## 結論

ポインタはWaveで高性能低レベルプログラミングを可能にする重要な機能の一つです。
直接的なメモリ制御が必要なシステム開発、ネイティブライブラリの実装、ハードウェア制御といった分野で特に重要な役割を果たします。

Waveはポインタの強力性を保ちつつも、コンパイラレベルでの検査や言語設計を通じ可能な限り安全で予測可能なポインタの使用を目指しています。
これにより、開発者は性能と安定性の間でバランスの取れた選択を行うことができます。