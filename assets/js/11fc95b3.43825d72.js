"use strict";(globalThis.webpackChunkwave_lang=globalThis.webpackChunkwave_lang||[]).push([[19],{7211(e,a,n){n.r(a),n.d(a,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"intro/roadmap","title":"Wave + Whale Integrated Development Roadmap v2","description":"This document is a roadmap outlining the step-by-step integration development process of the Wave language and Whale compiler toolchain.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/intro/roadmap.md","sourceDirName":"intro","slug":"/intro/roadmap","permalink":"/docs/intro/roadmap","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Run the first program","permalink":"/docs/intro/run"},"next":{"title":"Syntax","permalink":"/docs/syntax/"}}');var i=n(4848),s=n(8453);const o={sidebar_position:4},r="Wave + Whale Integrated Development Roadmap v2",l={},d=[{value:"Pre-Beta Stage",id:"pre-beta-stage",level:2},{value:"Alpha Stage",id:"alpha-stage",level:2},{value:"Beta Stage",id:"beta-stage",level:2},{value:"RC (Release Candidate) Stage",id:"rc-release-candidate-stage",level:2},{value:"Release Stage (v0.0.1)",id:"release-stage-v001",level:2},{value:"Development Meta Strategy",id:"development-meta-strategy",level:2}];function c(e){const a={code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(a.header,{children:(0,i.jsx)(a.h1,{id:"wave--whale-integrated-development-roadmap-v2",children:"Wave + Whale Integrated Development Roadmap v2"})}),"\n",(0,i.jsx)(a.p,{children:"This document is a roadmap outlining the step-by-step integration development process of the Wave language and Whale compiler toolchain.\nWave and Whale initially start as separate components, but ultimately aim to be fully integrated into one independent language ecosystem."}),"\n",(0,i.jsx)(a.p,{children:"The entire development stages follow the flow as below."}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-matlab",children:"pre-alpha \u2192 pre-beta \u2192 alpha \u2192 beta \u2192 rc \u2192 release\n"})}),"\n",(0,i.jsx)(a.p,{children:"Each stage proceeds based on the results of the previous stage, assuming unidirectional development where you do not revert to a previous structure once a stage is completed."}),"\n",(0,i.jsx)(a.hr,{}),"\n",(0,i.jsx)(a.h2,{id:"pre-beta-stage",children:"Pre-Beta Stage"}),"\n",(0,i.jsx)(a.p,{children:"The goal of the Pre-Beta stage is to complete the front end of the Wave language and implement the full functionality of the language based on the LLVM backend.\nIn this stage, Whale is not used; compilation and execution are entirely done through LLVM."}),"\n",(0,i.jsx)(a.p,{children:"Extending the syntax itself is not addressed at this stage.\nThe key goal is to make every grammatical element work based on the defined specifications.\nFocus on stabilizing frontend architecture like error message quality, type checking, variable scope handling, etc."}),"\n",(0,i.jsxs)(a.p,{children:["The scope of implementation includes variable declaration, output, and basic operations, as well as the completion of function definition and calls, conditions (",(0,i.jsx)(a.code,{children:"if"})," / ",(0,i.jsx)(a.code,{children:"else if"})," / ",(0,i.jsx)(a.code,{children:"else"}),"), loops (",(0,i.jsx)(a.code,{children:"while"})," / ",(0,i.jsx)(a.code,{children:"break"})," / ",(0,i.jsx)(a.code,{children:"continue"}),").\nIt also includes format output, explicit type specification, ",(0,i.jsx)(a.code,{children:"ptr<T>"})," type pointer design, ",(0,i.jsx)(a.code,{children:"array<T, N>"})," type array design."]}),"\n",(0,i.jsx)(a.p,{children:"In this stage, the Wave compiler is entirely written in Rust and uses inkwell and llvm-sys for LLVM IR generation and AOT execution."}),"\n",(0,i.jsx)(a.hr,{}),"\n",(0,i.jsx)(a.h2,{id:"alpha-stage",children:"Alpha Stage"}),"\n",(0,i.jsx)(a.p,{children:"The goal for the Alpha stage is to introduce the Whale backend and establish a structure where LLVM and Whale are used concurrently.\nLLVM remains the primary backend, and Whale is added as an optionally usable backend."}),"\n",(0,i.jsxs)(a.p,{children:["When running Wave code, you can choose which backend to use between LLVM and Whale through the ",(0,i.jsx)(a.code,{children:"--backend"})," option."]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-bash",children:"wavec run main.wave --backend=whale\nwavec run main.wave --backend=llvm\n"})}),"\n",(0,i.jsx)(a.p,{children:"In this stage, the IR structure of Whale itself is designed and defined.\nKey components such as Instruction, Value, Block are organized, and an IR Generator that converts Wave AST to Whale IR is implemented."}),"\n",(0,i.jsxs)(a.p,{children:["A code generator for Whale is also implemented, allowing execution in assembly or binary format.\nIn LLVM, types that are difficult or inefficient to implement, such as ultra-large integer types like ",(0,i.jsx)(a.code,{children:"i1024"})," and advanced pointer structures, are introduced in this stage as Whale-specific features."]}),"\n",(0,i.jsx)(a.p,{children:"As a checkpoint, it should be possible to have Hello World output from the Whale backend, and variable declaration and assignment, pointer handling, and IR debugging tools should function properly.\nThis is the stage where the conversion from Wave to Whale IR is substantially carried out."}),"\n",(0,i.jsx)(a.hr,{}),"\n",(0,i.jsx)(a.h2,{id:"beta-stage",children:"Beta Stage"}),"\n",(0,i.jsx)(a.p,{children:"The goal of the Beta stage is to fully transition to Whale and remove LLVM dependency.\nStarting from this stage, the compilation and execution of Wave use only Whale."}),"\n",(0,i.jsx)(a.p,{children:"All LLVM-related dependencies and modules are removed, and the code generation and execution path are optimized based on Whale.\nSimplifying and speeding up the flow from IR generation to execution is a key task."}),"\n",(0,i.jsx)(a.p,{children:"Design optimization passes for Whale IR, and improve code generation speed and execution efficiency.\nAll syntax of Wave should be perfectly supported based on the Whale backend at this stage."}),"\n",(0,i.jsx)(a.p,{children:"In terms of testing, both unit tests and the entire test suite are performed, verifying compatibility with WSON and the standard library, and checking cross-platform Whale builds."}),"\n",(0,i.jsx)(a.hr,{}),"\n",(0,i.jsx)(a.h2,{id:"rc-release-candidate-stage",children:"RC (Release Candidate) Stage"}),"\n",(0,i.jsx)(a.p,{children:"The goal of the RC stage is to start bootstrapping Wave.\nFrom this stage, gradually remove the Rust implementation of the Wave compiler and begin rewriting the Wave compiler in the Wave language itself."}),"\n",(0,i.jsx)(a.p,{children:"Rewrite the Wave IR generator based on Whale, replacing the core compiler logic and std/core libraries with Wave code.\nThrough this process, Whale enters the self-hosting phase."}),"\n",(0,i.jsx)(a.p,{children:"Upon successful bootstrap, the first Wave-native compiler is born."}),"\n",(0,i.jsx)(a.hr,{}),"\n",(0,i.jsx)(a.h2,{id:"release-stage-v001",children:"Release Stage (v0.0.1)"}),"\n",(0,i.jsx)(a.p,{children:"The Release stage signifies the official first release of Wave.\nAt this point, Wave and Whale form a completely integrated independent language ecosystem."}),"\n",(0,i.jsx)(a.p,{children:"Release components include the Wave language and standard library, Whale compiler toolchain, Vex package manager, and WSON data format."}),"\n",(0,i.jsxs)(a.p,{children:["Wave at this stage should have a compiler completely written in Wave code, and Whale's optimization should be complete.\nThe build and deployment flow through Vex is established, and cross OS builds like ",(0,i.jsx)(a.code,{children:"vex build --windows"})," should also be possible."]}),"\n",(0,i.jsx)(a.hr,{}),"\n",(0,i.jsx)(a.h2,{id:"development-meta-strategy",children:"Development Meta Strategy"}),"\n",(0,i.jsx)(a.p,{children:"Wave + Whale development is not a simple stage progression, but is based on a clear strategy.\nWhile developing Whale, adopt the train+rail strategy of simultaneously building the Wave backend, evolving both the backend structure and language design in parallel."}),"\n",(0,i.jsxs)(a.p,{children:["In the Alpha stage, the backend branching strategy via the ",(0,i.jsx)(a.code,{children:"--backend"})," option plays an important role, providing a basis for directly comparing and verifying LLVM and Whale."]}),"\n",(0,i.jsx)(a.p,{children:"After the RC, the structure is reversed, with a plan to reverse the structure where Wave code, through Whale, compiles Wave itself, proceeding in earnest."})]})}function h(e={}){const{wrapper:a}={...(0,s.R)(),...e.components};return a?(0,i.jsx)(a,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453(e,a,n){n.d(a,{R:()=>o,x:()=>r});var t=n(6540);const i={},s=t.createContext(i);function o(e){const a=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function r(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(s.Provider,{value:a},e.children)}}}]);