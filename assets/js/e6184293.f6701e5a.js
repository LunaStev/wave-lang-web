"use strict";(globalThis.webpackChunkwave_lang=globalThis.webpackChunkwave_lang||[]).push([[503],{816(e,t,n){n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"syntax/struct","title":"Struct","description":"Introduction","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/syntax/struct.md","sourceDirName":"syntax","slug":"/syntax/struct","permalink":"/docs/syntax/struct","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"sidebar_position":8},"sidebar":"tutorialSidebar","previous":{"title":"Inline Assembly","permalink":"/docs/syntax/inline_asm"},"next":{"title":"FFI","permalink":"/docs/syntax/ffi"}}');var i=n(4848),a=n(8453);const r={sidebar_position:8},c="Struct",l={},o=[{value:"Introduction",id:"introduction",level:2},{value:"Wave structures operate as value types.\nAll fields must have explicit types and must be initialized when a struct instance is created.\nThrough these rules, the state of the structure always maintains a complete and predictable form.",id:"wave-structures-operate-as-value-typesall-fields-must-have-explicit-types-and-must-be-initialized-when-a-struct-instance-is-createdthrough-these-rules-the-state-of-the-structure-always-maintains-a-complete-and-predictable-form",level:2},{value:"Struct Declaration Syntax",id:"struct-declaration-syntax",level:2},{value:"The order in which fields are written when declaring a struct is used as the memory layout order.\nWithin a struct, only field declarations are allowed; functions or methods cannot be included.\nThe operational logic is defined separately outside the struct.",id:"the-order-in-which-fields-are-written-when-declaring-a-struct-is-used-as-the-memory-layout-orderwithin-a-struct-only-field-declarations-are-allowed-functions-or-methods-cannot-be-includedthe-operational-logic-is-defined-separately-outside-the-struct",level:2},{value:"Struct Instantiation Syntax",id:"struct-instantiation-syntax",level:2},{value:"Struct Field Access Syntax",id:"struct-field-access-syntax",level:2},{value:"Struct Method Definition Syntax",id:"struct-method-definition-syntax",level:2},{value:"Using Struct as Function Argument",id:"using-struct-as-function-argument",level:2},{value:"Nested Struct",id:"nested-struct",level:2},{value:"Struct Arrays",id:"struct-arrays",level:2},{value:"Basic Operability of Structs",id:"basic-operability-of-structs",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"struct",children:"Struct"})}),"\n",(0,i.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(t.p,{children:"The struct in the Wave language is a key syntax element for declaring user-defined data types.\nUsing structures allows for different types of values to be grouped and represented as a single logical unit, which enables modeling of complex data structures clearly and safely."}),"\n",(0,i.jsx)(t.h2,{id:"wave-structures-operate-as-value-typesall-fields-must-have-explicit-types-and-must-be-initialized-when-a-struct-instance-is-createdthrough-these-rules-the-state-of-the-structure-always-maintains-a-complete-and-predictable-form",children:"Wave structures operate as value types.\nAll fields must have explicit types and must be initialized when a struct instance is created.\nThrough these rules, the state of the structure always maintains a complete and predictable form."}),"\n",(0,i.jsx)(t.h2,{id:"struct-declaration-syntax",children:"Struct Declaration Syntax"}),"\n",(0,i.jsxs)(t.p,{children:["A struct is declared using the ",(0,i.jsx)(t.code,{children:"struct"})," keyword.\nThe name of a structure uses PascalCase, and one or more fields can be defined in the structure body."]}),"\n",(0,i.jsxs)(t.p,{children:["Fields are declared in the form ",(0,i.jsx)(t.code,{children:"name: type;"}),", and a semicolon is required after each field declaration."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-wave",children:"struct Box {\n    size: i32;\n    weight: f32;\n}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"the-order-in-which-fields-are-written-when-declaring-a-struct-is-used-as-the-memory-layout-orderwithin-a-struct-only-field-declarations-are-allowed-functions-or-methods-cannot-be-includedthe-operational-logic-is-defined-separately-outside-the-struct",children:"The order in which fields are written when declaring a struct is used as the memory layout order.\nWithin a struct, only field declarations are allowed; functions or methods cannot be included.\nThe operational logic is defined separately outside the struct."}),"\n",(0,i.jsx)(t.h2,{id:"struct-instantiation-syntax",children:"Struct Instantiation Syntax"}),"\n",(0,i.jsxs)(t.p,{children:["A struct is created using a literal format with the struct name.\nA struct literal uses the format ",(0,i.jsx)(t.code,{children:"StructName { fieldName: value; ... It is written in the form of "}),"}."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-wave",children:"var b: Box = Box {\n    size: 42;\n    weight: 10.5;\n};\n"})}),"\n",(0,i.jsx)(t.p,{children:"When creating a struct, all defined fields must be initialized, and a compile error will occur if even one is omitted."}),"\n",(0,i.jsx)(t.p,{children:"When initializing, the order of fields does not need to match the struct declaration order, but the type of values passed to each field must exactly match the type defined in the struct.\nWave does not allow implicit type conversion during the initialization of struct fields."}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"struct-field-access-syntax",children:"Struct Field Access Syntax"}),"\n",(0,i.jsx)(t.p,{children:"Fields of a struct are accessed using dot notation.\nField access uses the same syntax for both reading and writing."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-wave",children:'println("Size: {}", b.size);\nprintln("Weight: {}", b.weight);\n'})}),"\n",(0,i.jsx)(t.p,{children:"An error will occur at compile time if you attempt to use a field name that does not exist.\nSince a struct is a value type, when assigning the entire struct or passing it as a function argument, all fields contained in the struct are copied together."}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"struct-method-definition-syntax",children:"Struct Method Definition Syntax"}),"\n",(0,i.jsxs)(t.p,{children:["The Wave language does not define methods directly within structs.\nInstead, the ",(0,i.jsx)(t.code,{children:"proto"})," keyword is used to declare a set of methods associated with the struct."]}),"\n",(0,i.jsxs)(t.p,{children:["A ",(0,i.jsx)(t.code,{children:"proto"})," block is an area for functions belonging to a specific struct, and functions defined in this block are used like methods of that struct."]}),"\n",(0,i.jsxs)(t.p,{children:["Methods use ",(0,i.jsx)(t.code,{children:"self"})," as the first parameter to receive the struct instance.\n",(0,i.jsx)(t.code,{children:"self"})," signifies the entire struct value and is passed by value copying."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-wave",children:'proto Box {\n    fun print(self) {\n        println("size={}, weight={}", self.size, self.weight);\n    }\n\n    fun added_size(self, x: i32) -> i32 {\n        return self.size + x;\n    }\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"Proto"})," blocks do not need to be located in the same file as the struct declaration, and multiple ",(0,i.jsx)(t.code,{children:"proto"})," blocks can distribute method definitions for the same struct."]}),"\n",(0,i.jsx)(t.p,{children:"Method calls use dot notation and operate in the same manner as regular function calls."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-wave",children:"b.print();\nvar n: i32 = b.added_size(5);\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"using-struct-as-function-argument",children:"Using Struct as Function Argument"}),"\n",(0,i.jsx)(t.p,{children:"When structs are passed as function arguments, they are handled by value copying.\nEven if you modify the fields of a struct within a function, it does not affect the struct instance on the calling side."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-wave",children:"fun calc(box: Box) -> i32 {\n    return box.size * 2;\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"The same value copying occurs when using structs as return values from functions.\nThis behavior ensures the immutability of structs and predictable data flow."}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"nested-struct",children:"Nested Struct"}),"\n",(0,i.jsx)(t.p,{children:"In Wave, another struct can be used as a field type within a struct.\nAs structs are complete types, you can freely nest them by including one struct within another."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-wave",children:"struct Position {\n    x: i32;\n    y: i32;\n}\n\nstruct Player {\n    name: str;\n    pos: Position;\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"Fields of nested structs are accessed using continuous dot notation."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-wave",children:'var p: Player = Player {\n    name: "Alice";\n    pos: Position { x: 10; y: 20; };\n};\n\nprintln("Player X: {}", p.pos.x);\nprintln("Player Y: {}", p.pos.y);\n'})}),"\n",(0,i.jsx)(t.p,{children:"You can nest another struct literal within a struct literal, and all field initialization rules apply in this case as well."}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"struct-arrays",children:"Struct Arrays"}),"\n",(0,i.jsxs)(t.p,{children:["Structs can be used as element types in arrays.\nWave's array syntax uses the ",(0,i.jsx)(t.code,{children:"array<type, length>"})," format, and struct types can also be specified as is."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-wave",children:'var players: array<Player, 3> = [\n    Player { name: "A"; pos: Position { x: 1; y: 2; }; },\n    Player { name: "B"; pos: Position { x: 3; y: 4; }; },\n    Player { name: "C"; pos: Position { x: 5; y: 6; }; }\n];\n'})}),"\n",(0,i.jsx)(t.p,{children:"When accessing elements of a struct array, use the array index first, then access internal struct fields via dot notation."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-wave",children:'println("Second Player X: {}", players[1].pos.x);\n'})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"basic-operability-of-structs",children:"Basic Operability of Structs"}),"\n",(0,i.jsx)(t.p,{children:"Wave's structs are user-defined types and do not automatically participate in arithmetic or comparison operations."}),"\n",(0,i.jsxs)(t.p,{children:["If equality comparison, sorting, hashing, numeric operations, etc., for structs are needed, they must be explicitly defined through a ",(0,i.jsx)(t.code,{children:"proto"})," block.\nWave does not provide implicit operators for structs, and all operations are required to be explicitly defined as a principle."]})]})}function u(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453(e,t,n){n.d(t,{R:()=>r,x:()=>c});var s=n(6540);const i={},a=s.createContext(i);function r(e){const t=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);